#!/bin/bash

git::commit_message() {
  git log -1 --pretty=%B -n 1
}

git::commit_message_full() {
  git log -1 --pretty=%B
}

git::commit_hash() {
  git rev-parse --short=9 HEAD
}

git::commit_hash_full() {
  git rev-parse HEAD
}

git::commit_author() {
  git show -s --format='%ae'
}

git::commit_timestamp() {
  local gitMainVersion=$(git --version | awk '{print $3}' | awk -F '.' '{print $1}')
  local gitSubVersion=$(git --version | awk '{print $3}' | awk -F '.' '{print $2}')

  if [ "$gitMainVersion" -ge "2" ] && [ "$gitSubVersion" -ge "7" ]; then
    git show -s --format=%cd --date="format:%Y-%m-%d"
  else
    git show -s --format=%cd --date=local
  fi
}

git::commit_timestamp_date() {
  local gitMainVersion=$(git --version | awk '{print $3}' | awk -F '.' '{print $1}')
  local gitSubVersion=$(git --version | awk '{print $3}' | awk -F '.' '{print $2}')

  if [ "$gitMainVersion" -ge "2" ] && [ "$gitSubVersion" -ge "7" ]; then
    git show -s --format=%cd --date="format:%Y-%m-%d"
  else
    git show -s --format=%cd --date=local
  fi
}

git::commit_timestamp_ms() {
  git show -s --format=%cd --date="format:%s"
}

git::commit_timestamp_human() {
  git show -s --format=%cd
}

git::fix_permissions() {
  # fix unsafe repository
  git config --global -l | grep "safe.directory=\*" >>/dev/null 2>&1
  if [ "$?" != "0" ]; then
    git config --global --add safe.directory "*"
  fi
}

git::origin_url() {
  local context=$1
  if [ -n "$context" ]; then
    cd $context
  fi

  git config --get remote.origin.url
}

git::namespace() {
  local context=$1
  if [ -n "$context" ]; then
    cd $context
  fi

  git::origin_url | awk -F '/' '{print $4}'
}

git::basename() {
  local context=$1
  if [ -n "$context" ]; then
    cd $context
  fi

  git::origin_url | awk -F '/' '{print $5}' | awk -F '.git' '{print $1}'
}

git::repo_name() {
  local context=$1
  if [ -n "$context" ]; then
    cd $context
  fi

  echo "$(git::namespace)/$(git::basename)"
}

git::branch() {
  local context=$1
  if [ -n "$context" ]; then
    cd $context
  fi

  git rev-parse --abbrev-ref HEAD
}

git::tag() {
  local context=$1
  if [ -n "$context" ]; then
    cd $context
  fi

  git describe --tags --abbrev=0
}

git::is_changed() {
  if [ "$(git status --porcelain)" != "" ]; then
    echo "true"
  else
    echo "false"
  fi
}

# stackoverflow: https://stackoverflow.com/questions/5139290/how-to-check-if-theres-nothing-to-be-committed-in-the-current-branch
git::is_added_before_commit() {
  git diff --cached --exit-code >>/dev/null 2>&1
  if [ "$?" != "0" ]; then
    echo "true"
  else
    echo "false"
  fi
}

git::is_ready_to_commit() {
  git::is_added_before_commit
}

git::repo_url() {
  local context=$1
  if [ -n "$context" ]; then
    cd $context
  fi

  local url=$(git::origin_url)
  echo "${url%.git}"
}

git::issue_url() {
  local url=$(git::repo_url)
  echo "${url}/issues"
}

git::pull_request_url() {
  local url=$(git::repo_url)
  echo "${url}/pulls"
}

git::merge_request_url() {
  local url=$(git::repo_url)
  echo "${url}/merge_requests"
}

git::url_ssh_to_http() {
  local ssh_url=$1
  local base_url=$2

  if [ -z "$ssh_url" ]; then
    log::error "[git::url_ssh_to_http] ssh_url is required"
    return 1
  fi

  if [ -z "$base_url" ]; then
    log::error "[git::url_ssh_to_http] base_url is required"
    return 1
  fi

  #  ssh://git@example.com:666/zero/example.git => zero/example
  #  ssh://git@example.com:666/zero/example => zero/example
  #  ssh://git@example.com/zero/example => zero/example
  # start with ssh://
  if [[ $ssh_url =~ ^ssh:// ]]; then
    local repo_namespace=$(echo "$ssh_url" | awk -F '/' '{print $4}')
    local repo_name=$(echo "$ssh_url" | awk -F '/' '{print $5}' | awk -F '.git' '{print $1}')
    echo "$base_url/$repo_namespace/$repo_name"
    return
  fi

  # git@github.com:zero/example.git => zero/example
  if [[ $ssh_url =~ ^git@ ]]; then
    local repo_namespace=$(echo "$ssh_url" | awk -F ':' '{print $2}' | awk -F '/' '{print $1}')
    local repo_name=$(echo "$ssh_url" | awk -F ':' '{print $2}' | awk -F '/' '{print $2}' | awk -F '.git' '{print $1}')
    echo "$base_url/$repo_namespace/$repo_name"
    return
  fi

  # http://github.com/zero/example.git => zero/example
  if [[ $ssh_url =~ ^http ]]; then
    local repo_namespace=$(echo "$ssh_url" | awk -F '/' '{print $4}')
    local repo_name=$(echo "$ssh_url" | awk -F '/' '{print $5}' | awk -F '.git' '{print $1}')
    echo "$base_url/$repo_namespace/$repo_name"
    return
  fi

  # http://github.com/zero/example.git => zero/example
  if [[ $ssh_url =~ ^git ]]; then
    local repo_namespace=$(echo "$ssh_url" | awk -F '/' '{print $4}')
    local repo_name=$(echo "$ssh_url" | awk -F '/' '{print $5}' | awk -F '.git' '{print $1}')
    echo "$base_url/$repo_namespace/$repo_name"
    return
  fi

  echo "[git::url_ssh_to_http] unsupported ssh_url: $ssh_url"
  return 1
}

git::has_tag() {
  local tag=$1
  if [ -z "$tag" ]; then
    log::error "[git::has_tag] tag is required"
    return 1
  fi

  git ls-remote --exit-code origin refs/tags/$tag >>/dev/null 2>&1
  if [ "$?" != "0" ]; then
    echo "false"
  else
    echo "true"
  fi
}

git::switch_tag() {
  local tag=$1
  if [ -z "$tag" ]; then
    log::error "[git::switch_tag] tag is required"
    return 1
  fi

  # apply proxy
  net::using_smart_proxy

  git fetch origin tag $tag >>/dev/null
  if [ "$?" != "0" ]; then
    log::error "[git::switch_tag] failed to fetch tag: $tag"
    return 1
  fi

  git checkout $tag >>/dev/null
}

git::use_version() {
  local version=$1
  if [ -z "$version" ]; then
    log::error "[git::use_version] version is required"
    return 1
  fi

  # if [ "$(git::has_tag $version)" != "true" ]; then
  #   log::error "[git::use_version] version($version) not found"
  #   return 1
  # fi

  git::switch_tag $version
}

# git::checkout checkouts git repository to context dir with specified branch
git::checkout() {
  local url=$1
  local branch=$2
  local context=$3

  if [ -z "$url" ]; then
    log::error "[git::checkout] url is required"
    return 1
  fi

  if [ -z "$branch" ]; then
    log::error "[git::checkout] branch is required"
    return 1
  fi

  if [ -z "$context" ]; then
    log::error "[git::checkout] context is required"
    return 1
  fi

  # if [ -d "$context" ]; then
  #   log::error "[git::checkout] context($context) is already exists, please remove it first."
  #   return 1
  # fi

  # apply proxy
  net::using_smart_proxy

  log::debug "HTTPS_PROXY: $HTTP_PROXY"

  if [ ! -d "$context" ]; then
    log::info "[git::checkout] check out new repository with branch $branch to $context ..."
    git clone $url -b $branch $context --depth 1 >>/dev/null 2>&1
    return
  fi

  cd $context

  local repo_url=$(git::repo_url)
  if [ "$repo_url" != "$url" ]; then
    log::info "[git::checkout] repo url not match(got: $repo_url, want: $url), create new ..."
    rm -rf $context
    git clone $url -b $branch $context --depth 1 >>/dev/null 2>&1
    cd -
    return
  fi

  log::info "[git::checkout] updating remote branch at context($context)..."
  git fetch origin >>/dev/null # $branch

  log::info "[git::checkout] switch to branch($branch) ..."
  git checkout $branch >>/dev/null 2>&1

  cd - >>/dev/null
}

export -f git::commit_message
export -f git::commit_message_full
export -f git::commit_hash
export -f git::commit_hash_full
export -f git::commit_author
export -f git::commit_timestamp
export -f git::commit_timestamp_date
export -f git::commit_timestamp_ms
export -f git::commit_timestamp_human

export -f git::fix_permissions

export -f git::origin_url
export -f git::namespace
export -f git::basename
export -f git::repo_name

export -f git::branch
export -f git::tag

export -f git::is_changed
export -f git::is_added_before_commit
export -f git::is_ready_to_commit

export -f git::repo_url
export -f git::issue_url
export -f git::pull_request_url
export -f git::merge_request_url

export -f git::url_ssh_to_http

export -f git::has_tag
export -f git::switch_tag
export -f git::use_version

export -f git::checkout
