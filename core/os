#!/bin/bash

os::homedir() {
  if [ -n "$HOME" ]; then
    echo $HOME
    return
  fi

  local home=$(echo ~)
  if [ -n "$HOME" ]; then
    echo $home
    return
  fi

  # @TODO
  cd
  pwd
}

os::username() {
  if [ -n "$GIT_USER" ]; then
    echo $GIT_USER
    return
  fi

  if [ -n "$USER" ]; then
    echo $USER
    return
  fi

  local homedir=$(os::homedir)
  if [ -n "$homedir" ]; then
    local user=$(path::basename $homedir)
    if [ -n "$user" ]; then
      echo $user
      return
    fi
  fi

  local user=$(id -u -n)
  if [ -n "$user" ]; then
    echo $user
    return
  fi

  log::error "Cannot get user by os::username"
  exit 1
}

os::shell() {
  echo $SHELL
}

os::bash_profile() {
  echo "$HOME/.bashrc"
}

os::zsh_profile() {
  echo "$HOME/.zshrc"
}

os::shell_profile() {
  if [ "$(os::is_zsh)" = "true" ]; then
    os::zsh_profile
  elif [ "$(os::is_bash)" = "true" ]; then
    os::bash_profile
  else
    echo "$HOME/.profile"
  fi
}

os::hostname() {
  # echo $HOST
  if [ "$(os::has_command hostname)" = "false" ]; then
    # reference: https://commandnotfound.cn/linux/1/347/hostname-%E5%91%BD%E4%BB%A4
    pm install -y hostname >>/dev/null 2>&1
  fi

  hostname
}

os::uptime() {
  if [ "$(os::is_macos)" = "true" ]; then
    uptime
  else
    if [ "$(os::has_command uptime)" = "false" ]; then
      # reference: https://commandnotfound.cn/linux/1/192/uptime-%E5%91%BD%E4%BB%A4
      if [ "$(os::has_command pacman)" ]; then
        pm install -y procps-ng >>/dev/null 2>&1
      elif [ "$(os::has_command yum)" ]; then
        pm install -y procps-ng >>/dev/null 2>&1
      elif [ "$(os::has_command dnf)" ]; then
        pm install -y procps-ng >>/dev/null 2>&1
      else
        pm install -y procps >>/dev/null 2>&1
      fi
    fi

    # echo $(uptime -p)
    uptime
  fi
}

os::arch() {
  local arch=$(uname -m)
  if [ "$arch" = "x86_64" ] || [ "$arch" = "amd64" ]; then
    arch="amd64"
  elif [ "$arch" = "aarch64" ] || [ "$arch" = "arm64" ]; then
    arch="arm64"
  fi

  echo $arch
}

os::platform() {
  if [ "$(os::is_macos)" = "true" ]; then
    echo "darwin"
    return
  fi

  echo "linux"
}

os::release() {
  if [ "$(os::is_macos)" = "true" ]; then
    if [ "$(os::has_command sw_vers)" = "true" ]; then
      echo "$(sw_vers -productName) $(sw_vers -productVersion)"
    else
      echo "macOS unknown version"
    fi
    return
  fi

  local issue=""

  # Red Hat
  # cat /proc/version | grep "Red Hat" >> /dev/null 2&>1
  # if [ "$?" != "0" ]; then
  #   echo $(cat /proc/version | grep -o "Red Hat [^-]*")
  #   return
  # fi

  if [ "$(os::has_command lsb_release)" = "true" ]; then
    issue=$(lsb_release -d)
  else
    issue=$(cat /etc/issue)
  fi

  local array=$issue
  local res=""

  for element in $array; do
    # echo "element: $element"
    if [ "$element" = "\n" ]; then
      continue
    fi

    if [ "$element" = "\l" ]; then
      continue
    fi

    if [ "$element" = "Description:" ]; then
      continue
    fi

    # core
    if [ "$res" = "" ]; then
      res=$element
    else
      res="$res $element"
    fi
  done

  echo $res
}

os::kernel() {
  echo $(uname -s)
}

os::pwd() {
  echo $PWD
}

os::tmp() {
  echo /tmp
}

os::tmp_dir() {
  mktemp -u
}

os::tmp_file() {
  mktemp
}

#
os::is_bash() {
  echo $(os::shell) | grep -o bash >>/dev/null 2>&1
  if [ "$?" != "0" ]; then
    echo "false"
    return
  fi

  echo "true"
}

os::is_zsh() {
  echo $(os::shell) | grep -o zsh >>/dev/null 2>&1
  if [ "$?" != "0" ]; then
    echo "false"
    return
  fi

  echo "true"
}

os::is_macos() {
  local kernel=$(os::kernel)

  if [ "$kernel" = "Darwin" ]; then
    echo true
  else
    echo false
  fi
}

os::is_linux() {
  local kernel=$(os::kernel)

  if [ "$kernel" = "Linux" ]; then
    echo true
  else
    echo false
  fi
}

os::is_centos() {
  if [ "$(os::has_command yum)" = "true" ]; then
    echo true
  else
    echo false
  fi
}

os::is_ubuntu() {
  if [ "$(os::has_command apt)" = "true" ]; then
    echo true
  else
    echo false
  fi
}

os::is_alpine() {
  if [ "$(os::has_command apk)" = "true" ]; then
    echo true
  else
    echo false
  fi
}

os::is_archlinux() {
  if [ "$(os::has_command pacman)" = "true" ]; then
    echo true
  else
    echo false
  fi
}

os::is_fedora() {
  if [ "$(os::has_command dnf)" = "true" ]; then
    echo true
  else
    echo false
  fi
}

os::is_docker() {
  if [ -f "/.dockerenv" ]; then
    echo "true"
    return
  fi

  if [ ! -f "/proc/self/cgroup" ]; then
    echo "false"
    return
  fi

  cat /proc/self/cgroup | grep docker >>/dev/null 2>&1
  if [ "$?" = "0" ]; then
    echo "true"
    return
  fi

  echo "false"
}

# os::is_docker_build_env checks is in docker build env
# os::is_docker_build_env@usage => true | false
# os::is_docker_build_env@example
os::is_docker_build_env() {
  if [ "$(os::hostname)" = "buildkitsandbox" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::top() {
  htop -t
}

os::is_command_exist() {
  local cmd=$1
  if command -v $cmd >>/dev/null 2>&1; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_support_color() {
  # if [ "$(echo $PS1)" != "" ]; then
  if [ "$TERM" = "xterm-256color" ]; then
    echo "true"
  elif [ "$TERM" = "xterm" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_ip() {
  local ip=$1

  if [ -z "$ip" ]; then
    log::error "ip is required"
    return
  fi

  # regexp syntax: [[ a =~ b ]]
  # if [[ "1.2.3.4" =~ "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$" ]]; then
  #   echo "true"
  # else
  #   echo "false"
  # fi

  # is ip
  echo $ip | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$" >>/dev/null 2>&1
  if [ "$?" = "0" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::cpu_brand() {
  # references:
  #   1. https://osxdaily.com/2011/07/15/get-cpu-info-via-command-line-in-mac-os-x/
  #   2. https://apple.stackexchange.com/questions/352769/does-macos-have-a-command-to-retrieve-detailed-cpu-information-like-proc-cpuinf
  if [ "$(os::is_macos)" = "true" ]; then
    sysctl -n machdep.cpu.brand_string
    return
  fi

  cat /proc/cpuinfo | grep "model name" | head -n 1 | awk -F ':' '{print $2}'
}

os::cpu_cores() {
  local cpus=0

  if [ "$(os::is_macos)" = "true" ]; then
    # also sysctl -n machdep.cpu.core_count
    cpus=$(sysctl -n hw.ncpu)
  else
    if [ "$(os::has_command nproc)" ]; then
      cpus=$(nproc)
    else
      cpus=$(cat /proc/cpuinfo | grep processor | wc -l)
    fi
  fi

  echo $cpus
}

os::memory_total() {
  local memory=0
  if [ "$(os::is_macos)" = "true" ]; then
    memory=$(hostinfo | grep memory | awk -F " " '{print $4}' | awk -F '.' '{print $1}')
  else
    memory=$(((($(cat /proc/meminfo | grep MemTotal | awk '{print $2}') / 1024 / 1024)) + 1))
  fi

  echo ${memory}
}

os::disk_total() {
  local disk=0

  if [ "$(os::is_macos)" = "true" ]; then
    if [ "$(os::has_command diskutil)" = "true" ]; then
      local disk_name=disk0
      diskutil info $disk_name >> /dev/null 2>&1
      if [ "$?" = "0" ]; then
        local disk_device=$(diskutil info $disk_name | grep "Disk Size")
        local disk_size=$(echo $disk_device | awk -F ' ' '{print $3}')
        local disk_unit=$(echo $disk_device | awk -F ' ' '{print $4}')
        disk="${disk_size}"
        if [ "$disk_unit" = "TB" ]; then
          disk=$(echo "$disk_size * 1024" | bc)
        fi
      fi
    fi
  else
    disk="$(os::disk_usage total)"
  fi

  echo "${disk}"
}


os::device_config() {
  local cpus="?"
  local memory="?"
  local disk="?"

  if [ "$(os::is_macos)" = "true" ]; then
    cpus=$(sysctl -n hw.ncpu)
    memory=$(hostinfo | grep memory | awk -F " " '{print $4}' | awk -F '.' '{print $1}')
    # disk=$(os::disk_usage total)

    if [ "$(os::has_command diskutil)" = "true" ]; then
      local disk_name=disk0
      diskutil info $disk_name >> /dev/null 2>&1
      if [ "$?" = "0" ]; then
        local disk_device=$(diskutil info $disk_name | grep "Disk Size")
        local disk_size=$(echo $disk_device | awk -F ' ' '{print $3}')
        local disk_unit=$(echo $disk_device | awk -F ' ' '{print $4}')
        disk="${disk_size}${disk_unit}"
      fi
    fi
  else
    cpus=$(cat /proc/cpuinfo | grep processor | wc -l)
    memory=$(((($(cat /proc/meminfo | grep MemTotal | awk '{print $2}') / 1024 / 1024)) + 1))
    disk="$(os::disk_usage total)G"
  fi

  echo "${cpus}C${memory}G - ${disk}"
}

os::cpu_usage() {
  if [ "$(os::is_macos)" = "true" ]; then
    top -l 1 | grep -E "^CPU" | grep -Eo '[^[:space:]]+%' | head -1 | awk -F '%' '{print $1}'
    return
  fi

  if [ "$(os::has_command top)" = "false" ]; then
    # reference: https://commandnotfound.cn/linux/1/190/top-%E5%91%BD%E4%BB%A4
    if [ "$(os::has_command pacman)" ]; then
      pm install -y procps-ng >>/dev/null 2>&1
    elif [ "$(os::has_command yum)" ]; then
      pm install -y procps-ng >>/dev/null 2>&1
    elif [ "$(os::has_command dnf)" ]; then
      pm install -y bro-devel >>/dev/null 2>&1
    else
      pm install -y procps >>/dev/null 2>&1
    fi
  fi
  top -bn1 | grep Cpu | head -n 1 | awk '{printf "%.2f", $2}'
}

os::memory_usage() {
  # unit: MB
  # used total percent

  # @TODO
  if [ "$(os::is_macos)" = "true" ]; then
    echo 0
    return
  fi

  if [ "$(os::has_command free)" = "false" ]; then
    # reference: https://commandnotfound.cn/linux/1/190/top-%E5%91%BD%E4%BB%A4
    if [ "$(os::has_command pacman)" ]; then
      pm install -y procps-ng >>/dev/null 2>&1
    elif [ "$(os::has_command yum)" ]; then
      pm install -y procps-ng >>/dev/null 2>&1
    elif [ "$(os::has_command dnf)" ]; then
      pm install -y procps-ng >>/dev/null 2>&1
    else
      pm install -y procps >>/dev/null 2>&1
    fi
  fi

  local type=$1
  local all=$(free -m | awk 'NR==2{printf "%s/%sMB (%.2f%%)", $3,$2,$3*100/$2 }')

  case $type in
  used)
    echo $all | awk -F '/' '{print $1}'
    ;;
  total)
    echo $all | awk -F '[/M]' '{print $2}'
    ;;
  percent)
    echo $all | awk -F '[(%]' '{print $2}'
    ;;
  *)
    echo $all
    ;;
  esac
}

os::disk_usage() {
  # unit: GB
  # used total percent

  # @TODO
  if [ "$(os::is_macos)" = "true" ]; then
    echo 0
    return
  fi

  if [ "$(os::has_command bc)" != "true" ]; then
    pm install -yqq bc >> /dev/null 2>&1
    if [ "$(os::has_command bc)" != "true" ]; then
      echo -1
      return
    fi
  fi 

  local type=$1
  # @TODO var will broken \n
  # local devices=$(df -h | grep "^/dev/")

  function get_used() {
    local value=0
    local lines=$(df -h | grep "^/dev/" | awk '{print $3}' | grep "G" | awk -F 'G' '{print $1}')
    for line in ${lines[@]}; do
      # value=$(($value + $line))
      value=$(echo "$value + $line" | bc)
    done

    echo $value
  }

  function get_total() {
    local value=0
    local lines=$(df -h | grep "^/dev/" | awk '{print $2}' | grep "G" | awk -F 'G' '{print $1}')
    for line in ${lines[@]}; do
      # value=$(($value + $line))
      value=$(echo "$value + $line" | bc)
    done

    echo $value
  }

  local usage=0

  case $type in
  used)
    usage=$(get_used)
    ;;
  total)
    usage=$(get_total)
    ;;
  percent)
    local used=$(get_used)
    local total=$(get_total)
    if [ "$total" = "" ] || [ "$total" = "0" ] || [ "$used" = "" ] || [ "$used" = "0" ] ; then
      usage=0
    else
      # usage=$(expr $used \* 100 / $total)
      # usage=$(( $used * 100 / $total ))
      # fix "Invalid Arithmetic Operator" when doing floating-point math in bash
      #   stackoverflow: https://stackoverflow.com/questions/35634255/invalid-arithmetic-operator-when-doing-floating-point-math-in-bash
      usage=$(echo "$used * 100 / $total" | bc)
      if [ "$?" != "0" ]; then
        usage=0
      fi
    fi
    ;;
  *)
    usage=$(echo $lines | awk '{printf "%s - %d %d GB (%s)\n", $1, $3,$2,$5}')
    ;;
  esac

  echo $usage
}

os::system_usage() {
  echo "cpu: $(os::cpu_usage)
memory: $(os::memory_usage)
disk: $(os::disk_usage)"
}

os::network_ip() {
  net::get_ip
}

os::network_ip_internal() {
  net::get_ip_internal
}

os::machine_id() {
  if [ "$(os::is_linux)" = "true" ]; then
    local machine_id0=/var/lib/dbus/machine-id
    local machine_id1=/etc/machine-id
    if [ -f $machine_id0 ]; then
      cat $machine_id0
    elif [ -f $machine_id1 ]; then
      cat $machine_id1
    else
      log::error "Cannot get machine id in linux"
      exit 1
    fi
  elif [ "$(os::is_macos)" = "true" ]; then
    echo $(ioreg -rd1 -c IOPlatformExpertDevice | grep "IOPlatformUUID" | awk -F '"' '{print $4}')
  else
    log::error "Cannot get machine id by unknown system"
    exit 1
  fi
}

os::rw_permission() {
  local path=$1
  # if [ -f $path ]; then
  #   if  [ ! -r $path ] || [ ! -w $path ]; then
  #     sudo chmod o+rw $path
  #   fi
  # fi

  # if [ -d $path ]; then
  #   if [ ! -w $path ]; then
  #     sudo chown -R $(os::username) $path
  #   fi
  # fi

  # path not exist
  if [ ! -e $path ]; then
    return
  fi

  if [ ! -r $path ] || [ ! -w $path ]; then
    sudo chmod a+rw $path

    log::debug "add rw permission: $path"
  fi
}

os::ensure_permission() {
  os::rw_permission $@
}

# @TODO
os::ensure_logs_permission() {
  os::ensure_permission $ZMICRO_LOG_PATH

  os::ensure_permission $ZMICRO_LOG_COMMON_PATH
  os::ensure_permission $ZMICRO_LOG_DEBUG_PATH
  os::ensure_permission $ZMICRO_LOG_ERROR_PATH
  os::ensure_permission $ZMICRO_LOG_UPDATE_PATH
  os::ensure_permission $ZMICRO_LOG_VERSION_PATH
  os::ensure_permission $ZMICRO_LOG_NOTIFY_PATH
  os::ensure_permission $ZMICRO_LOG_UPDATE_TIMESTAMP
}

os::is_pid_valid() {
  local pid=$1
  local pid_file=/proc/$pid/status
  if [ -f $pid_file ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::get_pid_memory() {
  local pid=$1
  local pid_file=/proc/$pid/status
  if [ ! -f $pid_file ]; then
    echo "0"
    return
  fi

  local memory=$(cat $pid_file | grep VmRSS | awk '{print $2}')
  if [ -z "$memory" ]; then
    echo "0"
    return
  fi

  echo $memory
}

os::kill_pid() {
  local pid=$1
  if [ "$(os::is_pid_valid $pid)" = "true" ]; then
    # log "kill pid: $pid"
    # -9 may cause child processes not killed
    # kill -9 $pid
    kill $pid
  fi
}

os::random_string() {
  local length=$1
  if [ -z "$length" ]; then
    length=32
  fi

  if [ "$(os::is_command_exist openssl)" = "false" ]; then
    cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w $length | head -n 1
    return
  fi

  openssl rand -hex $length
}

os::random_int() {
  local max=$1
  local min=$2
  if [ -z "$max" ]; then
    log::error "[os::random_int] max is required"
    return
  fi

  if [ -z "$min" ]; then
    min=0
  fi

  echo $(((RANDOM % $max) + $min))
}

os::random_id() {
  os::random_string 32
}

# it is useful for hold on situations
#   such as dockerfile CMD
os::sleep_infinity() {
  sleep infinity
}

os::hold_on() {
  os::sleep_infinity
}

os::timestamp() {
  timestamp
}

os::usage() {
  if [ "$(os::is_macos)" = "true" ]; then
    echo "-"
    return
  fi

  echo "cpu: $(os::cpu_usage percent)%, memory: $(os::memory_usage percent)%, disk: $(os::disk_usage percent)%"
}

os::info() {
  local ip=$(os::network_ip)
  local user=$(os::username)
  local homedir=$(os::homedir)
  local shell=$(os::shell)
  local id=$(os::device_id)
  local uptime=$(os::uptime)
  local hostname=$(os::hostname)
  local kernel=$(os::kernel)
  local platform=$(os::platform)
  local release=$(os::release)
  local distribution=$(os::distribution)
  local architecture=$(os::arch)
  local is_docker=false
  local device=$(os::device)
  local cpu_brand=$(os::cpu_brand)
  local load=$(os::usage)
  local timestamp=$(os::timestamp)

  local is_proxy_on=$(os::is_proxy_on)
  local is_clash_on=$(os::is_clash_on)
  local is_clashz_on=$(os::is_clashz_on)
  local is_shadowsocks_on=$(os::is_shadowsocks_on)

  if [ "$(os::is_macos)" != "true" ]; then
    # release=$(os::release)
    # distribution=$(os::distribution)
    is_docker=$(os::is_docker)
    # load="$(os::usage)"
  fi

#   local CI_INFO=""
#   if [ "$(os::is_ci)" = "true" ]; then
# CI_INFO"\
# ## CI env
# * GITHUB_REPOSITORY: $GITHUB_REPOSITORY\n\
# * GITHUB_REPOSITORY_OWNER:$GITHUB_REPOSITORY_OWNER\n\
# * GITHUB_REF_NAME: $GITHUB_REF_NAME\n\
# * GITHUB_REF: $GITHUB_REF\n\
# * GITHUB_SERVER_URL: $GITHUB_SERVER_URL\n\
# * RUNNER_NAME: $RUNNER_NAME\n\
# * RUNNER_OS: $RUNNER_OS\n\
# * RUNNER_ARCH: $RUNNER_ARCH\n\
# * RUNNER_TRACKING_ID: $RUNNER_TRACKING_ID\n\
# * RUNNER_TEMP: $RUNNER_TEMP\n\
# * RUNNER_USER: $RUNNER_USER\n\
# * RUNNER_TOOL_CACHE: $RUNNER_TOOL_CACHE\n\
# * RUNNER_WORKSPACE: $RUNNER_WORKSPACE\n\
# * RUNNER_PERFLOG: $RUNNER_PERFLOG\n\
# "
#   fi

  local info="\
## Network\n\
* public: $ip\n\
* internal: $(os::network_ip_internal)\n\
\n\
## User\n\
* current: $user\n\
* homedir: $homedir\n\
* all: $(users::all | tr '\n' ',')\n\
* online: \n\
$(users::online | tr '\n' ',')\n\
* histories: \n\
$(users::login::histories | head -5 | tr '\n' ',')\n\
* doing: \n\
$(users::doing)\n\
\n\
## WorkSpace\n\
* is_workspace: $(os::is_workspace)\n\
\n\
## System\n\
* shell: $shell\n\
* hostname: $hostname\n\
* arch: $architecture\n\
* kernel: $kernel\n\
* platform: $platform\n\
* distribution: $distribution\n\
* is_docker: $is_docker\n\
\n\
## Proxy\n\
* is_proxy_on: $is_proxy_on\n\
* is_clash_on: $is_clash_on\n\
* is_clashz_on: $is_clashz_on\n\
* is_shadowsocks_on: $is_shadowsocks_on\n\
* HTTP_PROXY: $HTTP_PROXY\n\
* HTTPS_PROXY: $HTTPS_PROXY\n\
* ALL_PROXY: $ALL_PROXY\n\
\n\
## Device\n\
* id: $id\n\
* device: $device\n\
* cpu brand: $cpu_brand\n\
${CI_INFO}
\n\
## Load\n\
* load: $load\n\
* uptime: $uptime\n\
\n\
* timestamp: $timestamp"

  echo $info
}

os::info_json() {
  local ip=$(os::network_ip)
  local ip_internal=$(os::network_ip_internal)
  local user=$(os::username)
  local homedir=$(os::homedir)
  local shell=$(os::shell)
  local id=$(os::device_id)
  local uptime=$(os::uptime)
  local hostname=$(os::hostname)
  local kernel=$(os::kernel)
  local release=$(os::release)
  local distribution=$(os::distribution)
  local architecture=$(os::arch)
  local platform=$(os::platform)
  local is_workspace=$(os::is_workspace)
  local is_docker=$(os::is_docker)
  local is_macos=$(os::is_macos)
  local is_linux=$(os::is_linux)
  local device=$(os::device)
  # local load=$(os::usage)
  local timestamp=$(os::timestamp)

  local cpu_brand=$(os::cpu_brand)
  local cpu_cores=$(os::cpu_cores)
  local memory_total=$(os::memory_total)
  local disk_total=$(os::disk_total)

  local cpu_load=$(os::cpu_usage percent)
  local memory_load=$(os::memory_usage percent)
  local disk_usage=$(os::disk_usage percent)

  local zmicro_version_origin=${ZMICRO_VERSION_ORIGIN}
  local zmicro_version=${ZMICRO_VERSION_NEW}
  local zmicro_version_detail=$(version::zmicro_detail)

  local is_ci=$(os::is_ci)
  local is_github_action=$(os::is_github_action)
  local is_gitlab_ci=$(os::is_gitlab_ci)
  local is_eunomia_ci=$(os::is_eunomia_ci)

  local is_proxy_on=$(os::is_proxy_on)
  local is_clash_on=$(os::is_clash_on)
  local is_clashz_on=$(os::is_clashz_on)
  local is_shadowsocks_on=$(os::is_shadowsocks_on)

  local is_unchanged=false
  if [ "$zmicro_version_origin" = "$zmicro_version" ]; then
    is_unchanged=true
  fi

  # local command_history="$(os::command_history 10)"
  # local top_10_mem_processes=$(os::top_process_by_mem)
  local command_history=""
  local top_10_mem_processes=""

  local info=$(cat <<-END
{
  "ip": "$ip",
  "ip_internal": "$ip_internal",
  "user": "$user",
  "homedir": "$homedir",
  "users_all": "$(users::all)",
  "users_online": "$(users::online)",
  "users_history": "$(users::login::histories | head -5)",
  "command_history": "$command_history",
  "top_10_mem_processes": "$top_10_mem_processes",
  "system_shell": "$shell",
  "system_hostname": "$hostname",
  "system_kernel": "$kernel",
  "system_distribution": "$distribution",
  "system_arch": "$architecture",
  "system_platform": "$platform",
  "device_id": "$id",
  "cpu_brand": "$cpu_brand",
  "cpu_cores": $cpu_cores,
  "memory_total": $memory_total,
  "disk_total": $disk_total,
  "cpu_load": $cpu_load,
  "memory_load": $memory_load,
  "disk_usage": $disk_usage,
  "is_workspace": $is_workspace,
  "is_docker": $is_docker,
  "is_macos": $is_macos,
  "is_linux": $is_linux,
  "zmicro_version_origin": "$zmicro_version_origin",
  "zmicro_version": "$zmicro_version",
  "zmicro_version_detail": "$zmicro_version_detail",
  "is_unchanged": $is_unchanged,
  "is_ci": $is_ci,
  "is_github_action": $is_github_action,
  "is_gitlab_ci": $is_gitlab_ci,
  "is_eunomia_ci": $is_eunomia_ci,
  "system_timestamp": "$timestamp",
  "is_proxy_on": "$is_proxy_on",
  "is_clash_on": "$is_clash_on",
  "is_clashz_on": "$is_clashz_on",
  "is_shadowsocks_on": "$is_shadowsocks_on",
  "http_proxy": "$HTTP_PROXY",
  "https_proxy": "$HTTPS_PROXY",
  "all_proxy": "$ALL_PROXY"
}
END
)

  echo $info
}

os::ps() {
  if [ "$(os::is_macos)" = "true" ]; then
    ps -A
  elif [ "$(os::is_centos)" = "true" ]; then
    pe -ef
  elif [ "$(os::is_ubuntu)" = "true" ]; then
    ps -aux
  else
    ps -aux
  fi
}

os::top() {
  if [ "$(os::is_macos)" = "true" ]; then
    top -l 1
  else
    if [ "$(os::has_command top)" = "false" ]; then
      # reference: https://commandnotfound.cn/linux/1/190/top-%E5%91%BD%E4%BB%A4
      if [ "$(os::has_command pacman)" ]; then
        pm install -y procps-ng >>/dev/null 2>&1
      elif [ "$(os::has_command yum)" ]; then
        pm install -y procps-ng >>/dev/null 2>&1
      elif [ "$(os::has_command dnf)" ]; then
        pm install -y bro-devel >>/dev/null 2>&1
      else
        pm install -y procps >>/dev/null 2>&1
      fi
    fi

    top -n 1
  fi
}

# @EXAMPLE
#  local key=$ZMICRO_HOME
#  os::get_env $key
os::get_env() {
  env::get $1
}

os::set_env() {
  env::set $1 $2
}

# os::inquirer interacts with users.
os::inquirer() {
  # load inquirer
  . $ZMICRO_PLUGINS_PATH/core-utils/core/inquirer/export

  local key=$1
  # 1. text       <args: key "text" question required default>
  # 2. yesno      <args: key "yesno" question required default>
  # 3. select     <args: key "select" choices question required>
  # 4. confirm (alias of yesno)
  # 5. radio   (alias of select)
  local type=$2
  #
  local question=$3
  local required=$4
  local default_value=$5
  
  # @TODO
  local choices=()

  if [ -z "$key" ]; then
    log::error "[os::inquirer] key is required"
    return
  fi

  if [ -z "$type" ]; then
    log::error "[os::inquirer] type is required, available: text, yesno"
    return
  fi

  # correct args
  if [ "$type" = "text" ]; then
    # os::inquirer value "text" "请输入 ？" "默认值"
    if [ "$required" != "true" ] && [ "$required" != "false" ]; then
      default_value=$required
      required="true"
    fi
  elif [ "$type" = "select" ] || [ "$type" = "radio" ]; then
    choices="$3"
    question=$4
    required=$5
    # default_value=$6
  fi

  if [ -z "$question" ]; then
    if [ "$type" = "text" ]; then
      question="请输入 $key:"
    elif [ "$type" = "yesno" ] || [ "$type" = "confirm" ]; then
      question="是否启用 $key?"
    elif [ "$type" = "select" ] || [ "$type" = "radio" ]; then
      question="请选择 $key:"
    fi
  fi

  if [ -z "$required" ]; then
    required=true
  fi

  if [ "$type" = "text" ]; then
    if [ "$required" = "true" ]; then
      inquirer::text "$question" value "$default_value" "value is required" inquirer::required
    else
      inquirer::text "$question" value "$default_value"
    fi
  elif [ "$type" = "yesno" ] || [ "$type" = "confirm" ]; then
    local choices=("Yes" "No")
    inquirer::select "$question" choices value
    if [ "$value" = "Yes" ]; then
      value="true"
    else
      value="false"
    fi
  elif [ "$type" = "select" ] || [ "$type" = "radio" ]; then
    # @TODO study from inquirer => select => _list_input
    eval _choices=( '"${'${choices}'[@]}"' )
    local _choices_length=${#_choices[@]}
    local _choices_index=0
    choices=()
    while [ "$_choices_index" -lt "$_choices_length" ]; do
      choices+=("${_choices[$_choices_index]}")
      _choices_index=$((_choices_index + 1))
    done  

    inquirer::select "$question" choices value
  else
    log::error "[os::inquirer] invalid type($type), options: text, yesno"
    exit 1
  fi

  if [ "$required" = "true" ]; then
    if [ -z "$value" ]; then
      log::error "[os::inquirer] value is required"
      os::inquirer "$@"
      return
    fi
  fi

  # @TODO
  export $key=$value
}

os::expect() {
  if [ "$(os::has_command expect)" != "true" ]; then
    log::info "[os::expect] install expect interpreter ..."
    pm install -yqq expect
  fi

  expect "$@"
}

os::add_user_to_docker_group() {
  local user=$1
  if [ -z "$user" ]; then
    user=$USER
  fi

  sudo usermod -aG docker $user
}

os::has_command() {
  os::is_command_exist $1
}

os::is_workspace() {
  if [ -d "/home/workspace" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::fix_permissions() {
  # log: fix all user
  log::fix_permissions

  # fix git permissions
  git::fix_permissions

  # home: fix current user
  sudo chown -R $USER $ZMICRO_HOME

  # /data
  # @TODO data 不能随便变更权限，会导致容器权限问题
  #   比如会导致 postgres 因为权限问题挂掉
  # if [ ! -w "$ZMICRO_APP_CONFIGS_PATH" ]; then
  #   # @TODO
  #   sudo chown -R $USER $ZMICRO_APP_CONFIGS_PATH
  # fi

  # /configs
  # if [ ! -w "$ZMICRO_APP_DATA_PATH" ]; then
  #   # @TODO
  #   sudo chown -R $USER $ZMICRO_APP_DATA_PATH
  # fi
}

os::distribution() {
  if [ "$(os::is_macos)" = "true" ]; then
    if [ "$(os::has_command sw_vers)" = "true" ]; then
      echo "$(sw_vers -productName) $(sw_vers -productVersion)"
    else
      echo "macOS unknown version"
    fi
    return
  fi

  local name="unknown"
  if [ "$(os::is_linux)" = "true" ]; then
    # fedora
    if [ -f /etc/fedora-release ]; then
      name=$(cat /etc/fedora-release)
    # RedHat/CentOS
    elif [ -f /etc/redhat-release ]; then
      name="$(cat /etc/redhat-release)"
    # OpenSuSE
    elif [ -f /etc/SuSE-release ]; then
      name=$(cat /etc/SuSE-release | tr "\n" ' ' | sed s/VERSION.*//)
    elif [ -f /etc/mandrake-release ]; then
      name="Mandrake ($(cat /etc/mandrake-release))"
    # Ubuntu
    elif [ -f /etc/os-release ]; then
      name=$(awk -F "PRETTY_NAME=" '{print $2}' /etc/os-release | tr -d '\n"')
    # Debian
    elif [ -f /etc/debian_version ]; then
      name="Debian $(cat /etc/debian_version)"
    elif [ -f /etc/issue ]; then
      # Archlinux/Alpine
      name=$(cat /etc/issue)
    fi

    if [ -f /etc/UnitedLinux-release ]; then
      name="${name}[$(cat /etc/UnitedLinux-release | tr "\n" ' ' | sed s/VERSION.*//)]"
    fi
  elif [ "$(os::is_macos)" = "true" ]; then
    name="MacOS $(sw_vers -productVersion)"
  fi

  echo $name
}

os::assert() {
  local ok=$1
  local message=$2

  if [ "$ok" != "" ] && [ "$message" = "" ]; then
    # echo "assert error, need two parameters: ok and message"
    # exit 1
    message=$ok
    ok=""
  fi

  if [ "$ok" = "" ] || [ "$ok" = "false" ]; then
    echo "assert: $message"
    exit 1
  fi
}

os::is_nodejs_installed() {
  # ZMICRO_NVM
  export NODE_HOME=/usr/local/node
  export NODE_USER_HOME=$HOME/.node
  export PATH=$NODE_HOME/bin:$NODE_USER_HOME/bin:$PATH

  if [ "$(os::has_command node)" = "true" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_zx_installed() {
  # ZMICRO_NVM
  export NODE_HOME=/usr/local/node
  export NODE_USER_HOME=$HOME/.node
  export PATH=$NODE_HOME/bin:$NODE_USER_HOME/bin:$PATH

  if [ "$(os::has_command zx)" = "true" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_go_installed() {
  # ZMICRO_GVM
  export GOHOME=/usr/local/go
  export GOPATH=$HOME/.go
  export PATH=$GOHOME/bin:$GOPATH/bin:$PATH

  if [ "$(os::has_command go)" = "true" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_deno_installed() {
  # ZMICRO_DVM
  export DENO_HOME=/usr/local/deno
  export DENO_USER_HOME=$HOME/.deno
  export PATH=$DENO_HOME/bin:$DENO_USER_HOME/bin:$PATH

  if [ "$(os::has_command deno)" = "true" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_rust_installed() {
  # ZMICRO_RSVM
  export RUST_HOME=/usr/local/rust
  export RUST_USER_HOME=$HOME/.rust
  export PATH=$RUST_HOME/rustc/bin:$RUST_HOME/cargo/bin:$RUST_USER_HOME/bin:$PATH

  if [ "$(os::has_command rustc)" = "true" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::support_method() {
  local method=$1
  # echo "method: $method"
  command -v $method >>/dev/null 2>&1
  if [ "$?" = "0" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::healthcheck() {
  local url=$1
   if [ -z "$url" ]; then
    log::error "[os::healthcheck] url is required"
    return
  fi

  net::is_url_visitable $url
}

# @TODO this is an example used in service/restart
# which is a good example for seperating options before service name
# 可以把选项提前，一直没有找到好方法，这里只是一个例子
#
os::get_options() {
  local args_length=${#@}
  local args_index=0
  while [ "$1" != "" ]; do
    args_index=$((args_index + 1))
    case $1 in
      -h | --help)
        help
        exit 0
        ;;
      -p | --pull)
        pull=true
        ;;
      -u | --upgrade)
        pull=true
        ;;
      *)
        if [ "$args_index" != "$args_length" ]; then
          log::error "Unknown option: $1"
          exit 1
        else
          service_name=$1
        fi
        ;;
    esac
    shift
  done
}

os::open() {
  local url=$1
  if [ -z "$url" ]; then
    log::error "[os::open] url is required"
    return 1
  fi

  if [ "$(os::is_macos)" = "true" ]; then
    open $url
  elif [ "$(os::is_linux)" = "true" ]; then
    xdg-open $url
  else
    log::error "[os::open] unsupported os"
    return 1
  fi
}

os::encode_uri_component() {
  local string="$1"
  local strlen=${#string}
  local encoded=""
  local pos c o

  for (( pos=0 ; pos<strlen ; pos++ )); do
     c=${string:$pos:1}
     case "$c" in
        [-_.~a-zA-Z0-9] ) o="${c}" ;;
        * )               printf -v o '%%%02x' "'$c"
     esac
     encoded+="${o}"
  done
  echo "${encoded}"
}

os::base64_encode() {
  local string="$1"
  if [ -z "$string" ]; then
    log::error "[os::base64_encode] string is required"
    return 1
  fi

  local encoded=$(echo -n "$string" | base64)
  echo "$encoded"
}

os::base64_decode() {
  local string="$1"
  if [ -z "$string" ]; then
    log::error "[os::base64_decode] string is required"
    return 1
  fi

  local decoded=$(echo -n "$string" | base64 -d)
  echo "$decoded"
}

# os::md5 gets the md5 sume of string or file.
# os::md5@usage 
# os::md5@example helloworld
# os::md5@example $ZMICRO_HOME/mod
os::md5() {
  local string="$1"
  if [ -z "$string" ]; then
    log::error "[os::md5] string or path is required"
    return 1
  fi

  # file
  if [ -f "$string" ]; then
    local filepath=$string
    # mac
    if [ "$(os::is_macos)" = "true" ]; then
      md5 -q $filepath
    else
      # linux
      md5sum $filepath | awk '{print $1}'
    fi
    return
  fi
  
  if [ "$(os::has_command md5sum)" = "true" ]; then
    echo -n "$string" | md5sum | awk '{print $1}'
  else
    echo -n "$string" | openssl md5
  fi
}

os::wget() {
  if [ "$(os::has_command wget)" != "true" ]; then
    pm install -y wget
  fi

  # apply proxy
  net::using_smart_proxy

  wget "$@"
}

os::curl() {
  # apply proxy
  net::using_smart_proxy

  if [ "$(os::has_command curl)" != "true" ]; then
    pm install -y curl
  fi

  # 1. retry mechanism: https://stackoverflow.com/questions/42873285/curl-retry-mechanism
  # 2. follow redirect
  # 3. @TODO continue
  curl \
    --connect-timeout 10 \
    --retry 5 \
    --retry-delay 1 \
    -L \
    "$@"
}

os::download() {
  local filepath=$1
  local url=$2
  if [ -z "$filepath" ]; then
    log::error "[os::download] filepath(.1) is required"
  fi

  if [ -z "$url" ]; then
    log::error "[os::download] url(.2) is required"
  fi

  os::curl --progress-bar -fSL $url -o $filepath
}

os::device() {
  os::device_config
}

# os::device_id get the device id
# os::device_id@usage os::device_id
os::device_id() {
  os::machine_id
}

os::is_ci() {
  if [ -n "$CI" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_github_action() {
  if [ -n "$GITHUB_ACTIONS" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_gitlab_ci() {
  if [ -n "$GITLAB_CI" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::is_eunomia_ci() {
  if [ -n "$EUNOMIA_CI" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::command_history() {
  local lines=$1

  if [ -f "$HOME/.zsh_history" ]; then
    if [ -n "$lines" ]; then
      cat $HOME/.zsh_history | tail -n $lines
      return
    fi

    cat $HOME/.zsh_history
    return
  fi

  if [ -f "$HOME/.bash_history" ]; then
    if [ -n "$lines" ]; then
      cat $HOME/.bash_history | tail -n $lines
      return
    fi

    cat $HOME/.bash_history
    return
  fi

  echo "[os::command_history] unsupported shell: $shell, unknown history"

  # if [ "$(os::is_zsh)" = "true" ]; then
  #   if [ -f "$HOME/.zsh_history" ]; then
  #     if [ -n "$lines" ]; then
  #       cat $HOME/.zsh_history | tail -n $lines
  #       return
  #     fi

  #     cat $HOME/.zsh_history
  #     return
  #   fi

  #   echo "no history found"
  #   return
  # elif [ "$(os::is_bash)" = "true" ]; then
  #   if [ -f "$HOME/.bash_history" ]; then
  #     if [ -n "$lines" ]; then
  #       cat $HOME/.bash_history | tail -n $lines
  #       return
  #     fi

  #     cat $HOME/.bash_history
  #     return
  #   fi
    
  #   echo "no history found"
  #   return
  # else
  #   echo "[os::command_history] unsupported shell: $shell"
  #   return 1
  # fi
}

os::top_process_by_mem() {
  if [ "$(os::is_macos)" = "true" ]; then
    ps -em | head -n 10
  else
    ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head -n 10
  fi
}

os::ssh() {
  net::using_smart_proxy

  local SSH_OPTIONS=""
  if [ -n "$PROXY_IP" ] && [ -n "$PROXY_PORT" ]; then
    SSH_OPTIONS='ProxyCommand nc -x $PROXY_IP:$PROXY_PORT %h %p'
  fi

  if [ -n "$SSH_OPTIONS" ]; then
    ssh -o "$SSH_OPTIONS" "$@"
  else
    ssh $@
  fi
}

os::git() {
  net::using_smart_proxy

  git "$@"
}

os::gzfetch() {
  net::using_smart_proxy

  if [ "$(os::is_command_exist gzfetch)" != "true" ]; then
    local tmp_error_file=$(os::tmp_file)
    zmicro package install gzfetch >> /dev/null 2>$tmp_error_file
    if [ "$?" != "0" ]; then
      log::error "[os::gzfetch] failed to install gzfetch"
      log::error "[os::gzfetch] error detail: $(cat $tmp_error_file)"
      return 1
    fi
  fi

  gzfetch "$@"
}

os::copy() {
  local text=$1
  if [ -z "$text" ]; then
    log::error "[os::copy] text is required"
    return 1
  fi

  # if [ "$(os::has_command pbcopy)" = "true" ]; then
  #   log::error "[os::copy] failed to copy(reason: pbcopy not found)"
  #   return 1
  # fi

  # macos
  if [ "$(os::is_macos)" = "true" ]; then
    echo "$text" | pbcopy
    return
  fi

  # linux
  # https://linux.cn/article-9917-1.html
  if [ "$(os::has_command xclip)" = "true" ]; then
    log::info "[os::copy] install dependencies: xclip and xel ..."
    pm install -yqq xclip xsel
  fi

  echo "$text" | xclip -selection clipboard
}

# os::usr_bin_dir gets the user bin directory.
os::usr_bin_dir() {
  local usr_bin_dir=/usr/bin

  if [ "$(os::is_macos)" = "true" ]; then
    usr_bin_dir=/usr/local/bin
  fi

  echo "$usr_bin_dir"
}

# os::usr_lib_dir gets the user lib directory.
os::usr_lib_dir() {
  local usr_lib_dir=/usr/lib

  if [ "$(os::is_macos)" = "true" ]; then
    usr_lib_dir=/usr/local/lib
  fi

  echo "$usr_lib_dir"
}

os::which() {
  if [ "$(os::has_command which)" != "true" ]; then
    pm install -yqq which
  fi

  which "$@"
}

# os::create_large_file creates a large file for testing purposes.
# os::create_large_file@usage <filepath> <size>
# os::create_large_file@example $PWD/test.bin 10240 (size: 10G)
os::create_large_file() {
  local filepath=$1
  local size=$2

  if [ -z "$filepath" ]; then
    filepath="./largefile.tmp"
  fi

  if [ -z "$size" ]; then
    size=1024
  fi

  dd if=/dev/urandom of=$filepath bs=1M count=$size >>/dev/null 2>&1
}

os::timeout() {
  if [ "$(os::has_command gztimeout)" = "false" ]; then
    zmicro package install gztimeout
  fi

  gztimeout "$@"
}

os::unzip() {
  if [ "$(os::has_command unzip)" != "true" ]; then
    pm install -y unzip
  fi

  unzip "$@"
}

os::tar() {
  if [ "$(os::has_command tar)" != "true" ]; then
    pm install -y tar
  fi

  tar "$@"
}

os::is_file_type_tar_gz() {
  local name=$1

  # .tar.gz
  echo "${name##*/}" | grep ".tar.gz" >> /dev/null 2>&1
  if [ "$?" = "0" ]; then
    echo "true"
    return
  fi

  # .tgz
  echo "${name##*/}" | grep ".tgz" >> /dev/null 2>&1
  if [ "$?" = "0" ]; then
    echo "true"
    return 
  fi

  echo "false"
}

os::is_file_type_zip() {
  local name=$1
  if [ "${name##*.}" = "zip" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::extract() {
  local filepath=$1
  if [ -z "$filepath" ]; then
    log::error "[os::extract] filepath is required"
    return 1
  fi

  local tmp_error_file=$(os::tmp_file)

  if [ "$(os::is_file_type_tar_gz $filepath)" = "true" ]; then
    os::tar -zxvf $filepath >> /dev/null 2>$tmp_error_file
    if [ "$?" != "0" ]; then
      log::error "[os::extract] failed to extract file type(tar.gz): $filepath."
      log::error "[os::extract] error detail: $(cat $tmp_error_file)"
      return 1
    fi
  elif [ "$(os::is_file_type_zip $filepath)" = "true" ]; then
    os::unzip -xo $filepath >> /dev/null 2>$tmp_error_file
    if [ "$?" != "0" ]; then
      log::error "[os::extract] failed to extract file type(zip): $filepath."
      log::error "[os::extract] error detail: $(cat $tmp_error_file)"
      return 1
    fi
  else
    log::error "[os::extract] unsupported file type: $filepath."
    return 1
  fi
}

os::is_clash_on() {
  net::is_port_visitable 127.0.0.1 7890
}

os::is_clashz_on() {
  net::is_port_visitable 127.0.0.1 17890
}

os::is_shadowsocks_on() {
  net::is_port_visitable 127.0.0.1 1080
}

os::is_proxy_on() {
  if [ -n "$HTTPS_PROXY" ] || [ -n "$HTTP_PROXY" ] || [ -n "$ALL_PROXY" ]; then
    echo "true"
  else
    echo "false"
  fi
}

os::get_system_http_proxy() {
  # macos
  if [ "$(os::is_macos)" = "true" ]; then
    local is_enabled=$(scutil --proxy | grep HTTPEnable | awk '{print $3}')
    if [ "${is_enabled}" = "1" ]; then
      local ip="$(scutil --proxy | grep HTTPProxy | awk '{print $3}')"
      local port="$(scutil --proxy | grep HTTPPort | awk '{print $3}')"
      echo "http://$ip:$port"
      return
    fi
  fi

  # linux @TODO

  echo ""
}

os::get_system_https_proxy() {
  # macos
  if [ "$(os::is_macos)" = "true" ]; then
    local is_enabled=$(scutil --proxy | grep HTTPSEnable | awk '{print $3}')
    if [ "${is_enabled}" = "1" ]; then
      local ip="$(scutil --proxy | grep HTTPSProxy | awk '{print $3}')"
      local port="$(scutil --proxy | grep HTTPSPort | awk '{print $3}')"
      echo "http://$ip:$port"
      return
    fi
  fi

  # linux @TODO

  echo ""
}

os::get_system_socks_proxy() {
  # macos
  if [ "$(os::is_macos)" = "true" ]; then
    local is_enabled=$(scutil --proxy | grep SOCKSEnable | awk '{print $3}')
    if [ "${is_enabled}" = "1" ]; then
      local ip="$(scutil --proxy | grep SOCKSProxy | awk '{print $3}')"
      local port="$(scutil --proxy | grep SOCKSPort | awk '{print $3}')"
      echo "socks5://$ip:$port"
      return
    fi
  fi

  # linux @TODO

  echo ""
}

# os::get_system_current_network_adapter gets system network adapter
# os::get_system_current_network_adapter@usage  => adapter_name
# os::get_system_current_network_adapter@example
os::get_system_current_network_adapter() {
  local currentservice=""
  if [ "$(os::is_macos)" = "true" ]; then
    # https://apple.stackexchange.com/questions/191879/how-to-find-the-currently-connected-network-service-from-the-command-line
    while read -r line; do
      local sname=$(echo "$line" | awk -F  "(, )|(: )|[)]" '{print $2}')
      local sdev=$(echo "$line" | awk -F  "(, )|(: )|[)]" '{print $4}')
      #echo "Current service: $sname, $sdev, $currentservice"
      if [ -n "$sdev" ]; then
          ifout="$(ifconfig "$sdev" 2>/dev/null)"
          echo "$ifout" | grep 'status: active' > /dev/null 2>&1
          rc="$?"
          if [ "$rc" -eq 0 ]; then
              currentservice="$sname"
              # currentdevice="$sdev"
              # currentmac=$(echo "$ifout" | awk '/ether/{print $2}')

              # may have multiple active devices, so echo it here
              # echo "$currentservice, $currentdevice, $currentmac"
          fi
      fi
    done <<< "$(networksetup -listnetworkserviceorder | grep 'Hardware Port')"
  fi

  echo "$currentservice"
}

# os::set_system_network_proxy sets system network proxy
# os::set_system_network_proxy@usage adapter, proxy_ip, proxy_port, status => exit_code(1 | 0)
# os::set_system_network_proxy@example
os::set_system_network_proxy() {
  local adapter="$1"
  local proxy_ip="$2"
  local proxy_port="$3"
  local status="$4"
  if [ "$adapter" = "" ]; then
    log::error "[os::set_system_network_proxy] network adapter is required"
    return 1
  fi

  if [ "$proxy_ip" = "" ]; then
    log::error "[os::set_system_network_proxy] network proxy_ip is required"
    return 1
  fi

  if [ "$proxy_port" = "" ]; then
    log::error "[os::set_system_network_proxy] network proxy_port is required"
    return 1
  fi

  if [ "$status" != "on" ] && [ "$status" != "off" ]; then
    log::error "[os::set_system_network_proxy] status must in on | off, but got $status."
    return 1
  fi

  if [ "$(os::is_macos)" = "true" ]; then
    networksetup -setwebproxy ${adapter} ${proxy_ip} ${proxy_port} && networksetup -setwebproxystate ${adapter} ${status}
    networksetup -setsecurewebproxy ${adapter} ${proxy_ip} ${proxy_port} && networksetup -setsecurewebproxystate ${adapter} ${status}
    networksetup -setsocksfirewallproxy ${adapter} ${proxy_ip} ${proxy_port} && networksetup -setsocksfirewallproxystate ${adapter} ${status}
    networksetup -setproxybypassdomains ${adapter} Empty
  else
    log::error "[os::set_system_network_proxy] not support current os, current only support macos"
    return 1
  fi
}

os::make_executable() {
  local filepath=$1
  if [ -z "$filepath" ]; then
    log::error "[$(timestamp)] filepath is required"
    return 1
  fi

  if [ ! -f "$filepath" ]; then
    log::error "[$(timestamp)] file($filepath) not found or not a file"
    return 1
  fi

  chmod 755 $filepath
}

# os::install install bin to bin dir, you can add new name
# os::install@usage source_bin_file target_bin_dir [target_bin_name]
# os::install@example
os::install() {
  local bin_file=$1
  local target_bin_dir=$2
  local target_bin_name=$3

  if [ -z "$bin_file" ]; then
    log::error "[$(timestamp)] bin_file is required"
    return 1
  fi

  if [ -z "$target_bin_dir" ]; then
    log::error "[$(timestamp)] target_bin_dir is required"
    return 1
  fi

  if [ ! -f "$bin_file" ]; then
    log::error "[$(timestamp)] bin_file($bin_file) not found or not a file"
    return 1
  fi

  if [ ! -d "$target_bin_dir" ]; then
    log::error "[$(timestamp)] target_bin_dir($target_bin_dir) not found or not a directory"
    return 1
  fi

  os::make_executable $bin_file

  if [ -n "$target_bin_name" ]; then
    sudo mv $bin_file $target_bin_dir/$target_bin_name
  else
    sudo mv $bin_file $target_bin_dir
  fi
}

# os::hostnamectl safe hostnamectl
# os::hostnamectl@usage ...
os::hostnamectl() {
  # @TODO
  # if [ "$(os::has_command hostnamectl)" = "false" ]; then
  #   # reference: https://commandnotfound.cn/linux/1/347/hostname-%E5%91%BD%E4%BB%A4
  #   pm install -y hostnamectl >>/dev/null 2>&1
  # fi
  
  hostnamectl "$@"
}

os::gpm() {
  if [ "$(os::has_command gpm)" != "true" ]; then
    pm::npm install -g @cliz/gpm
  fi

  net::using_smart_proxy
  
  gpm "$@"
}

os::gzfly() {
  if [ "$(os::has_command gzfly)" != "true" ]; then
    zmicro package install gzfly
  fi

  gzfly "$@"
}

os::gzssh() {
  if [ "$(os::has_command gzssh)" != "true" ]; then
    zmicro package install gzssh
  fi

  gzssh "$@"
}

os::gzlighthouse() {
  if [ "$(os::has_command gzlighthouse)" != "true" ]; then
    zmicro package install gzlighthouse
  fi

  gzlighthouse "$@"
}

os::gztemplate() {
  if [ "$(os::has_command gztemplate)" != "true" ]; then
    zmicro package install gztemplate
  fi

  gztemplate "$@"
}

# os::os_name get current os name
# os::os_name@description now support macos | ubuntu | centos | alpine | archlinux | fedora
os::os_name() {
  if [ "$(os::is_macos)" = "true" ]; then
    echo "macos"
    return
  fi

  if [ "$(os::is_ubuntu)" = "true" ]; then
    echo "ubuntu"
    return
  fi

  if [ "$(os::is_centos)" = "true" ]; then
    echo "centos"
    return
  fi

  if [ "$(os::is_alpine)" = "true" ]; then
    echo "alpine"
    return
  fi

  if [ "$(os::is_archlinux)" = "true" ]; then
    echo "archlinux"
    return
  fi

  if [ "$(os::is_fedora)" = "true" ]; then
    echo "fedora"
    return
  fi

  echo "unknown"
}

os::forever() {
  if [ -z "$1" ]; then
    log::error "[os::forever] command is required"
    return 1
  fi

  echo "[$(timestamp)] forever command: $@ ..."
  local count=1
  while true; do
    echo "[$(timestamp)][time: $count] run: $@..."
    "$@"
    sleep 1
    count=$((count + 1))
  done
}

os::run_commands_in_remote_server() {
  set +e
  
  local server=$1
  local commands=${@:2}
  
  if [ -z "$server" ]; then
    log::error "[os::run_commands_in_remote_server] server is required"
    return 1
  fi

  if [ -z "$commands" ]; then
    log::error "[os::run_commands_in_remote_server] commands is required"
    return 1
  fi

  log::info "[$(timestamp)] server: $server"
  log::info "[$(timestamp)] commands: $commands"

  ssh -o "StrictHostKeyChecking=no" $@
}

# os::is_in_vscode checks if in vscode.
# os::is_in_vscode@usage 
# os::is_in_vscode@example os::is_in_vscode
os::is_in_vscode() {
  if [ -n "$VSCODE_INJECTION" ]; then
    echo "true"
  else
    echo "false"
  fi
}

# os::is_in_iterm2 checks if in iterm2.
# os::is_in_iterm2@usage 
# os::is_in_iterm2@example os::is_in_iterm2
os::is_in_iterm2() {
  # if [ "$TERM_PROGRAM" = "iTerm.app" ]; then
  if [ "$LC_TERMINAL" = "iTerm2" ]; then
    echo "true"
  else
    echo "false"
  fi
}

export -f os::arch
export -f os::platform
export -f os::release
export -f os::kernel
export -f os::distribution
export -f os::shell

export -f os::homedir
export -f os::username
export -f os::shell_profile
export -f os::zsh_profile
export -f os::bash_profile
export -f os::hostname
export -f os::uptime

export -f os::ps
export -f os::top

export -f os::pwd
export -f os::tmp
export -f os::tmp_dir
export -f os::tmp_file

export -f os::is_bash
export -f os::is_zsh
export -f os::is_linux
export -f os::is_macos

export -f os::is_centos
export -f os::is_ubuntu
export -f os::is_alpine
export -f os::is_archlinux
export -f os::is_fedora

export -f os::is_docker
export -f os::is_docker_build_env

export -f os::top
export -f os::is_command_exist
export -f os::is_support_color

export -f os::has_command

export -f os::device_config

export -f os::cpu_usage
export -f os::memory_usage
export -f os::disk_usage
export -f os::system_usage

export -f os::network_ip
export -f os::network_ip_internal

export -f os::machine_id

export -f os::rw_permission
export -f os::ensure_permission
export -f os::ensure_logs_permission

export -f os::is_pid_valid
export -f os::get_pid_memory
export -f os::kill_pid

export -f os::random_string
export -f os::random_int

export -f os::random_id

export -f os::sleep_infinity
export -f os::hold_on

export -f os::timestamp

export -f os::usage
export -f os::info
export -f os::info_json

export -f os::get_env
export -f os::set_env

export -f os::inquirer
export -f os::expect

export -f os::add_user_to_docker_group

export -f os::is_workspace

export -f os::fix_permissions

export -f os::assert

export -f os::is_nodejs_installed
export -f os::is_zx_installed
export -f os::is_go_installed
export -f os::is_deno_installed
export -f os::is_rust_installed

export -f os::is_ip

export -f os::support_method

export -f os::healthcheck

export -f os::get_options

export -f os::open
export -f os::copy

export -f os::encode_uri_component

export -f os::base64_encode
export -f os::base64_decode

export -f os::md5

export -f os::wget
export -f os::curl
export -f os::download

export -f os::device
export -f os::device_id

export -f os::cpu_brand
export -f os::cpu_cores
export -f os::memory_total
export -f os::disk_total

export -f os::is_ci
export -f os::is_github_action
export -f os::is_gitlab_ci
export -f os::is_eunomia_ci

export -f os::command_history

export -f os::top_process_by_mem

export -f os::ssh
export -f os::git

export -f os::gzfetch

export -f os::usr_bin_dir
export -f os::usr_lib_dir

export -f os::which

export -f os::create_large_file

export -f os::timeout

export -f os::unzip
export -f os::tar

export -f os::is_file_type_tar_gz
export -f os::is_file_type_zip

export -f os::extract

export -f os::is_clash_on
export -f os::is_clashz_on
export -f os::is_shadowsocks_on

export -f os::is_proxy_on

export -f os::get_system_http_proxy
export -f os::get_system_https_proxy
export -f os::get_system_socks_proxy

export -f os::get_system_current_network_adapter
export -f os::set_system_network_proxy

export -f os::make_executable
export -f os::install

export -f os::hostnamectl

export -f os::gpm

export -f os::gzfly
export -f os::gzssh
export -f os::gzlighthouse
export -f os::gztemplate

export -f os::os_name

export -f os::forever
export -f os::run_commands_in_remote_server

export -f os::is_in_vscode
export -f os::is_in_iterm2
